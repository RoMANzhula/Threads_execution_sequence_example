public class Main {
    public static void main(String[] args) throws InterruptedException { //головний метод програми, який кидає виняток
        // переривання потоку (блокування) при використанні методу sleep()
        System.out.println("All threads starting their works..."); //виводимо в консоль літерал
        System.out.println("-----------separator-------------"); //виводимо в консоль розділювач між нашими процесами створення потоків

        ////в цьому циклі ми створимо 7 потоків і побачимо, що вони виводяться без порядку (не по черзі)
        for (int i = 0; i < 7; i++) { //створюємо цикл з кількістю ітерацій = 7 (від 0 до 6) по зростанню
            FirstThreadExample thread1 = new FirstThreadExample(); //оскільки клас FirstThreadExample є нащадком (потомком)
            //класу Thread, то ми потік thread1 створюємо одразу (не так, як у випадку з інтерфейсом Runnable, де для об'єкта
            //класу потрібно окремо створювати потік, а потім ініціалізувати його в конструкторі, як аргумент)
            thread1.start(); //запускаємо потік thread1 (реалізуємо метод run())
        }

        ////в цьому циклі ми створимо 7 потоків і спробуємо впорядкувати виведення потоків в консоль
        try { //намагаємось виконати наступний код
            Thread.sleep(1500); //зупиняємо головний потік на 1,5 секунди
            System.out.println("-----------separator------------"); //виводимо в консоль розділювач між нашими процесами створення потоків

            for (int i = 0; i < 7; i++) { //знову створюємо цикл на 7 ітерацій по зростанню
                FirstThreadExample thread2 = new FirstThreadExample(); //створюємо новий потік того ж класу, як у першому варіанті
                thread2.start(); //запускаємо потік і цим реалізуємо метод run()
                thread2.join(1); //але тут ми призупиняємо цей потік на 1 мілісекунду, що дозволяє нам впорядкувати
                //послідовне виведення потоків на консоль
            }
        } catch (InterruptedException e) { //ловимо виключення (обробляємо метод sleep())
            e.printStackTrace(); //виводимо стек трасування виключення (як сталося і в якому місці)
        }

        System.out.println("-----------separator-------------"); //виводимо в консоль розділювач між нашими процесами створення потоків

        ////в цьому випадку ми створимо потік, який буде виводити цикл, описаний в класі SecondThreadExample (виведе 5 рядків), який
        ////реалізує інтерфейс Runnable
        Thread.sleep(1500); //зупиняємо головний потік на 1,5 секунди
        SecondThreadExample thread3 = new SecondThreadExample(); //створюємо новий об'єкт класу SecondThreadExample
        Thread th1 = new Thread(thread3); //створюємо новий потік, в конструктор якого, як аргумент, ми передаємо створений об'єкт класу SecondThreadExample
        th1.start(); //запускаємо потік, який реалізує метод run() того класу, для якого він був створений

        ////тепер виконаємо попередній варіант, але наш клас ми успадкуємо від класу Thread
        try { //намагаємось виконати наступний код
            Thread.sleep(1500); //зупиняємо головний потік на 1,5 секунди
            System.out.println("-----------separator-------------"); //виводимо в консоль розділювач між нашими процесами створення потоків
            ThirdThreadExample thread4 = new ThirdThreadExample(); //створюємо новий потік для класу ThirdThreadExample (точніше для реалізації його методу run())
            thread4.start(); //запускаємо потік, який реалізує метод run() того класу, для якого він був створений
        } catch (InterruptedException e) { //ловимо виключення (обробляємо метод sleep())
            e.printStackTrace(); //виводимо стек трасування виключення (як сталося і в якому місці)
        }

        Thread.sleep(1500); //зупиняємо головний потік на 1,5 секунди
        System.out.println("-----------separator-------------"); //виводимо в консоль розділювач між нашими процесами створення потоків

        ////знову створимо цикл, але зробимо його у порядку спадання - побачимо, що результат аналогічний першому прикладу, тобто
        ////потоки виводяться без впорядкування
        for (int i = 5; i > 0; i--) { //цикл з ітерацією = 5, але в порядку спадання
            FourthThreadExample thread5 = new FourthThreadExample(); //створюємо новий потік для класу FourthThreadExample (точніше для реалізації його методу run())
            thread5.start(); //запускаємо потік, який реалізує метод run() того класу, для якого він був створений
        }

        ////в цьому випадку ми спробуємо впорядкувати роботу двох допоміжних потоків для класу-нащадка класу Thread
        try { //намагаємось виконати наступний код
            Thread.sleep(1500); //зупиняємо головний потік на 1,5 секунди
            System.out.println("-----------separator-------------"); //виводимо в консоль розділювач між нашими процесами створення потоків

                FifthThreadExample thread6 = new FifthThreadExample(); //створюємо новий потік
                FifthThreadExample thread7 = new FifthThreadExample(); //створюємо ще один потік
                thread6.start(); //запускаємо потік, який реалізує метод run() того класу, для якого він був створений

                try { //намагаємось виконати наступний код
                    thread6.join(); //кажемо головному потоку, що потрібно почекати цей потік (який позначений методом join())
                } catch (InterruptedException e) { //ловимо виключення (обробляємо метод sleep())
                    e.printStackTrace(); //виводимо стек трасування виключення (як сталося і в якому місці)
                }
                thread7.start(); //запускаємо потік, який реалізує метод run() того класу, для якого він був створений

                try { //намагаємось виконати наступний код
                    thread6.join(); //кажемо головному потоку, що потрібно почекати цей потік (який позначений методом join())
                    thread7.join(); //кажемо головному потоку, що потрібно почекати цей потік (який позначений методом join())
                } catch (InterruptedException e) { //ловимо виключення (обробляємо метод sleep())
                    e.printStackTrace(); //виводимо стек трасування виключення (як сталося і в якому місці)
                }

        } catch (InterruptedException e) { //ловимо виключення (обробляємо метод sleep())
            e.printStackTrace(); //виводимо стек трасування виключення (як сталося і в якому місці)
        }

        ////аналогічний спосіб попередньому, але клас вже реалізує інтерфейс Runnable
        try { //намагаємось виконати наступний код
            Thread.sleep(1500); //зупиняємо головний потік на 1,5 секунди
            System.out.println("-----------separator-------------"); //виводимо в консоль розділювач між нашими процесами створення потоків

            FifthThreadExample fifthThreadExample1 = new FifthThreadExample(); //створюємо новий об'єкт класу FifthThreadExample
            FifthThreadExample fifthThreadExample2 = new FifthThreadExample(); //створюємо ще один новий об'єкт класу FifthThreadExample
            Thread thread8 = new Thread(fifthThreadExample1); //створюємо потік для об'єкта класу FifthThreadExample
            Thread thread9 = new Thread(fifthThreadExample2); //створюємо ще один новий потік для об'єкта FifthThreadExample
            thread8.start(); //запускаємо потік, який реалізує метод run() того класу, для якого він був створений

            try { //намагаємось виконати наступний код
                thread8.join(); //головний потік чекає на цей потік, поки він не завершить виконання
            } catch (InterruptedException e) { //ловимо виключення (обробляємо метод sleep())
                e.printStackTrace(); //виводимо стек трасування виключення (як сталося і в якому місці)
            }
            thread9.start(); //запускаємо потік, який реалізує метод run() того класу, для якого він був створений

            try { //намагаємось виконати наступний код
                thread9.join(); //головний потік чекає на цей потік, поки він не завершить виконання
            } catch (InterruptedException e) { //ловимо виключення (обробляємо метод sleep())
                e.printStackTrace(); //виводимо стек трасування виключення (як сталося і в якому місці)
            }

        } catch (InterruptedException e) { //ловимо виключення (обробляємо метод sleep())
            e.printStackTrace(); //виводимо стек трасування виключення (як сталося і в якому місці)
        }
    }
}
