public class Main {
    public static void main(String[] args) throws InterruptedException { //главный метод приложения, который бросает исключение
        // прерывания потока (блокировки) при использовании метода sleep()
        System.out.println("All threads starting their works..."); //выводим в консоль литерал
        System.out.println("-----------separator-------------"); //выводим в консоль разделитель между нашими процессами создания потоков

        ////в данном цикле мы создадим 7 потоков и увидим что они беспорядочно (не по порядку) выведутся в консоль
        for (int i = 0; i < 7; i++) { //создаем цикл с количеством итераций = 7 (от 0 до 6) по возрастанию
            FirstThreadExample thread1 = new FirstThreadExample(); //так как класс FirstThreadExample является наследником(потомком)
            //класса Thread, то мы поток thread1 создаем сразу (не так, как в случае с интерфейсом Runnable, где для обьекта
            //класса нужно отдельно создавать поток, а потом инициализировать его в конструкторе, в качестве аргумента)
            thread1.start(); //запускаем поток thread1 (реализуем метод run())
        }


        ////в данном цикле мы создадим 7 потоков и попытаемся упорядочить вывод потоков в консоль
        try { //пытаемся выполнить следующий код
            Thread.sleep(1500); //усыпим главный поток на 1,5 секунды
            System.out.println("-----------separator------------"); //выводим в консоль разделитель между нашими процессами создания потоков

            for (int i = 0; i < 7; i++) { //снова создаем цикл на 7 итераций по возрастанию
                FirstThreadExample thread2 = new FirstThreadExample(); //создаем новый поток того же класса, как в первом варианте
                thread2.start(); //запускаем поток и этим реализуем метод run()
                thread2.join(1); //но тут мы приостанавливаем данный поток на 1 миллисекунду, что позволяет нам упорядочить
                //последовательный вывод потоков на консоль
            }
        } catch (InterruptedException e) { //ловим исключение (обрабатываем метод sleep())
            e.printStackTrace(); //пишем стек трассировки исключения (как произошло и в каком месте)
        }

        System.out.println("-----------separator-------------"); //выводим в консоль разделитель между нашими процессами создания потоков


        ////в данном случае мы создадим поток, который будет выводить цикл, описанный в классе SecondThreadExample (выведет 5 строк), который
        ////реализует интерфейс Runnable
        Thread.sleep(1500); //усыпим главный поток на 1,5 секунды
        SecondThreadExample thread3 = new SecondThreadExample(); //создаем новый обьект класса SecondThreadExample
        Thread th1 = new Thread(thread3); //создаем новый поток, в конструктор которого, в качестве аргумента, мы кладем созданный обьект класса SecondThreadExample
        th1.start(); //запускаем поток, который реализует метод run() того класса, для которого он был создан


        ////теперь проделаем предидущий вариант, но наш класс мы унаследуем от класса Thread
        try { //пытаемся выполнить следующий код
            Thread.sleep(1500); //усыпим главный поток на 1,5 секунды
            System.out.println("-----------separator-------------"); //выводим в консоль разделитель между нашими процессами создания потоков
            ThirdThreadExample thread4 = new ThirdThreadExample(); //создаем новый поток для класса ThirdThreadExample(точнее для реализации его метода run())
            thread4.start(); //запускаем поток, который реализует метод run() того класса, для которого он был создан
        } catch (InterruptedException e) { //ловим исключение (обрабатываем метод sleep())
            e.printStackTrace(); //пишем стек трассировки исключения (как произошло и в каком месте)
        }

        Thread.sleep(1500); //усыпим главный поток на 1,5 секунды
        System.out.println("-----------separator-------------"); //выводим в консоль разделитель между нашими процессами создания потоков


        ////снова создадим цикл, но проитерируем его в порядке убывания - видим, что результат аналогичен самому первому примеру, т.е.
        ////потоки выводятся неупорядоченно
        for (int i = 5; i > 0; i--) { //цикл с итерацией = 5, но в порядке убывания
            FourthThreadExample thread5 = new FourthThreadExample(); //создаем новый поток для класса FourthThreadExample(точнее для реализации его метода run())
            thread5.start(); //запускаем поток, который реализует метод run() того класса, для которого он был создан
        }


        ////в данном случае мы попытаемся упорядочить работу двух вспомогательных потоков для класса наследника класса Thread
        try { //пытаемся выполнить следующий код
            Thread.sleep(1500); //усыпим главный поток на 1,5 секунды
            System.out.println("-----------separator-------------"); //выводим в консоль разделитель между нашими процессами создания потоков

                FifthThreadExample thread6 = new FifthThreadExample(); //создаем новый поток
                FifthThreadExample thread7 = new FifthThreadExample(); //создаем еще один поток
                thread6.start(); //запускаем поток, который реализует метод run() того класса, для которого он был создан

                try { //пытаемся выполнить следующий код
                    thread6.join(); //говорим главному потоку, что нужно обождать данный поток (который помечен методом join())
                } catch (InterruptedException e) { //ловим исключение (обрабатываем метод sleep())
                    e.printStackTrace(); //пишем стек трассировки исключения (как произошло и в каком месте)
                }
                thread7.start(); //запускаем поток, который реализует метод run() того класса, для которого он был создан

                try { //пытаемся выполнить следующий код
                    thread6.join(); //говорим главному потоку, что нужно обождать данный поток (который помечен методом join())
                    thread7.join(); //говорим главному потоку, что нужно обождать данный поток (который помечен методом join())
                } catch (InterruptedException e) { //ловим исключение (обрабатываем метод sleep())
                    e.printStackTrace(); //пишем стек трассировки исключения (как произошло и в каком месте)
                }

        } catch (InterruptedException e) { //ловим исключение (обрабатываем метод sleep())
            e.printStackTrace(); //пишем стек трассировки исключения (как произошло и в каком месте)
        }


        ////аналогичный способ предидущему, но класс уже реализует интерфейс Runnable
        try { //пытаемся выполнить следующий код
            Thread.sleep(1500); //усыпим главный поток на 1,5 секунды
            System.out.println("-----------separator-------------"); //выводим в консоль разделитель между нашими процессами создания потоков

            FifthThreadExample fifthThreadExample1 = new FifthThreadExample(); //создаем новый обьект класса FifthThreadExample
            FifthThreadExample fifthThreadExample2 = new FifthThreadExample(); //создаем еще один новый обьект класса FifthThreadExample
            Thread thread8 = new Thread(fifthThreadExample1); //создаем поток для обьекта класса FifthThreadExample
            Thread thread9 = new Thread(fifthThreadExample2); //создаем еще один новый поток для обьекта FifthThreadExample
            thread8.start(); //запускаем поток, который реализует метод run() того класса, для которого он был создан

            try { //пытаемся выполнить следующий код
                thread8.join(); //говорим главному потоку, что нужно обождать данный поток (который помечен методом join())
            } catch (InterruptedException e) { //ловим исключение (обрабатываем метод sleep())
                e.printStackTrace(); //пишем стек трассировки исключения (как произошло и в каком месте)
            }
            thread9.start(); //запускаем поток, который реализует метод run() того класса, для которого он был создан

            try { //пытаемся выполнить следующий код
                thread8.join(); //говорим главному потоку, что нужно обождать данный поток (который помечен методом join())
                thread9.join(); //говорим главному потоку, что нужно обождать данный поток (который помечен методом join())
            } catch (InterruptedException e) { //ловим исключение (обрабатываем метод sleep())
                e.printStackTrace(); //пишем стек трассировки исключения (как произошло и в каком месте)
            }

        } catch (InterruptedException e) { //ловим исключение (обрабатываем метод sleep())
            e.printStackTrace(); //пишем стек трассировки исключения (как произошло и в каком месте)
        }

        System.out.println("-----------separator-------------"); //выводим в консоль разделитель между нашими процессами создания потоков

        System.out.println("Every threads are finished their works."); //выводим в консоль литерал

    }
}